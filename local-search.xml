<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>系统设计基础</title>
    <link href="/2023/03/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、性能"><a href="#一、性能" class="headerlink" title="一、性能"></a>一、性能</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol><li><strong>相应时间</strong></li></ol><p>指某个请求从发出到接收到响应消耗的时间。</p><p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p><ol start="2"><li><strong>吞吐量</strong></li></ol><p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p><ol start="3"><li><strong>并发用户数</strong></li></ol><p>指系统能同时处理的并发用户请求数量。</p><p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req&#x2F;s，那么平均响应时间应该为 0.01s。</p><p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p><ul><li>多 CPU</li><li>IO 等待时间</li></ul><p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p><p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>集群</strong></li></ol><p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p><ol start="2"><li><strong>缓存</strong></li></ol><p>缓存能够提高性能的原因如下：</p><ul><li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li><li>缓存数据可以位于靠近用户的地理位置上；</li><li>可以将计算结果进行缓存，从而避免重复计算。</li></ul><ol start="3"><li><strong>异步</strong></li></ol><p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p><h1 id="二、伸缩性"><a href="#二、伸缩性" class="headerlink" title="二、伸缩性"></a>二、伸缩性</h1><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p><h2 id="伸缩性与性能"><a href="#伸缩性与性能" class="headerlink" title="伸缩性与性能"></a>伸缩性与性能</h2><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p><p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p><h2 id="实现伸缩性"><a href="#实现伸缩性" class="headerlink" title="实现伸缩性"></a>实现伸缩性</h2><p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p><p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p><p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p><h1 id="三、扩展性"><a href="#三、扩展性" class="headerlink" title="三、扩展性"></a>三、扩展性</h1><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p><p>实现可扩展主要有两种方式：</p><ul><li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li><li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li></ul><h1 id="四、可用性"><a href="#四、可用性" class="headerlink" title="四、可用性"></a>四、可用性</h1><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p><p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p><p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p><h1 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h1><p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thrift、Protobuf和Avro的比较</title>
    <link href="/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p><strong>Thrift</strong> 是由 Facebook 主导开发的一个跨平台、支持多语言的，通过定义 IDL 文件，自动生成 RPC 客户端与服务端通信代码的工具，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码并由生成的代码负责RPC协议层和传输层的实现。</p><p><strong>Thrift</strong> 是由 Facebook 开源的一个RPC框架，用来进行可扩展且跨语言的服务的开发，使得各种编程语言间无缝结合的、高效的服务。我们依据Thrift的规范 简单定义访问接口，通过Thrift编译器编译生成各种编程语言代码，实现各种语言模块之间的高效互访问，速度比Google的Protocol Buffers还要快。Thrift可以说它是现在最优秀的分布式通信机制，实现了在大型分布式集群中各独立模块之间的高效协同</p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p><strong>protocol buffer</strong> 是一种序列化与结构化数据的一种机制，具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点。</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p><strong>Apache Avro</strong> 是一个二进制的数据序列化系统。实际上 Avro 除了序列化之外，像 MP 一样也提供了远程调用（ RPC ）功能。 Avro 是属于 Hadoop 的一个子项目，由 Hadoop 的 创始人 Doug Cutting 牵头开发，设计用于支持大批量数据交换的应用，依赖模式 (Schema) 来实现数据结构定义，模式由 JSON 对象来表示， Avro 也被作为一种 RPC 框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在 Avro 中被称为消息 (Message) 。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。</p><h2 id="二、框架优缺点分析"><a href="#二、框架优缺点分析" class="headerlink" title="二、框架优缺点分析"></a>二、框架优缺点分析</h2><h3 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h3><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li><li>proto文件生成目标代码，简单易用</li><li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li><li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li><li>支持多种语言（可以把proto文件看做IDL文件）</li><li>Netty等一些框架集成</li></ul><p><strong>缺点</strong></p><ul><li>官方只支持C++,JAVA和Python语言绑定</li><li>二进制可读性差（貌似提供了Text_Fromat功能）</li><li>二进制不具有自描述特性</li><li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li><li>只涉及序列化和反序列化技术，不涉及RPC功能（类似XML或者JSON的解析器）</li></ul><h3 id="Apache-Thrift"><a href="#Apache-Thrift" class="headerlink" title="Apache Thrift"></a>Apache Thrift</h3><p><strong>应用</strong></p><ul><li>Facebook的开源的日志收集系统(scribe: <a href="https://github.com/facebook/scribe">https://github.com/facebook/scribe</a>)</li><li>淘宝的实时数据传输平台(TimeTunnel <a href="http://code.taobao.org/p/TimeTunnel/wiki/index">http://code.taobao.org/p/TimeTunnel/wiki/index</a>)</li><li>Evernote开放接口(<a href="https://github.com/evernote/evernote-thrift">https://github.com/evernote/evernote-thrift</a>)</li><li>Quora(<a href="http://www.quora.com/Apache-Thrift">http://www.quora.com/Apache-Thrift</a>)</li><li>HBase( <a href="http://abloz.com/hbase/book.html#thrift">http://abloz.com/hbase/book.html#thrift</a> )</li><li>…</li></ul><p><strong>优点</strong></p><ul><li>支持非常多的语言绑定</li><li>thrift文件生成目标代码，简单易用</li><li>消息定义文件支持注释</li><li>数据结构与传输表现的分离，支持多种消息格式</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li></ul><p><strong>缺点</strong></p><ul><li>和protobuf一样不支持动态特性</li></ul><h3 id="Apache-Avro"><a href="#Apache-Avro" class="headerlink" title="Apache Avro"></a>Apache Avro</h3><p><strong>应用</strong></p><ul><li>Hadoop RPC （<a href="http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F%EF%BC%89">http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F）</a></li></ul><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高</li><li>使用JSON描述模式</li><li>模式和数据统一存储，消息自描述，不需要生成stub代码（支持生成IDL）</li><li>RPC调用在握手阶段交换模式定义</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li><li>支持动态消息</li><li>模式定义允许定义数据的排序（序列化时会遵循这个顺序）</li><li>提供了基于Jetty内核的服务基于Netty的服务</li></ul><p><strong>缺点</strong></p><ul><li>只支持Avro自己的序列化格式</li><li>语言绑定不如Thrift丰富</li></ul><h2 id="三、性能对比"><a href="#三、性能对比" class="headerlink" title="三、性能对比"></a>三、性能对比</h2><p>由于thrift功能较protobuf丰富,因此单从序列化机制上进行性能比较,手机html制作按照序列化后字节数、序列化时间、反序列化时间三个指标进行对thrift的二进制、压缩、protobuf三种格式进行对比发现：Protobuf序列化后的字节数较少,符合w3c标准而且序列化和反序列化的时间也较短.</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p><strong>相同点：</strong></p><ol><li><strong>简化处理对xml文件的处理</strong></li></ol><ul><li>数据类型相对固定的情况下，不论是thrift还是protobuf都会比直接处理xml要方便很多</li></ul><blockquote><p>常用的跨语言通信方案：</p><ul><li>基于SOAP消息格式的WebService</li><li>基于JSON消息格式的RESTful 服务</li></ul><p>以上两种方案的弊端：</p><ul><li>XML体积太大，解析性能极差</li><li>JSON体积相对较小，解析相对较快，但表达能力较弱</li></ul></blockquote><p><strong>不同点：</strong></p><ol><li><strong>创作者</strong></li></ol><p>thrift由facebook出品，protobuffer由google出品；</p><ol start="2"><li><strong>语言支持</strong></li></ol><ul><li><p>Thrift: 支持的语言更广泛一些c++, java, python,ruby, csharp, haskell, ocmal, erlang, cocoa, php</p></li><li><p>protobuf 目前还是只支持c++, java, python</p></li></ul><ol start="3"><li><strong>协议支持</strong></li></ol><ul><li><p>Thrift支持多种协议格式. Thrift的代码实现，有专门的TProtocol和TTransport抽象，相互配合，可以实现多种协议，方便集成各种传输方式。至少目前Thrift就能使用json作为序列化协议。 </p></li><li><p>protobuf只安心一种协议，并下决心把这个格式做好。输入输出也是标准的stream。</p></li></ul><ol start="4"><li><strong>跨平台问题</strong></li></ol><ul><li><p>thrift目前不支持Windows平台 </p></li><li><p>protobuf没有这个问题，提供了visual studio的项目文件，可以很顺利的在windows平台下编译。</p></li></ul><ol start="5"><li><strong>易用性</strong></li></ol><ul><li>thrift侧重点是构建夸语言的可伸缩的服务，特点就是支持的语言多，同时提供了完整的rpc service framework，可以很方便的直接构建服务，不需要做太多其他的工作。</li></ul><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><p><a href="https://blog.csdn.net/hu2010shuai/article/details/53009349">https://blog.csdn.net/hu2010shuai/article/details/53009349</a></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC基本概念</title>
    <link href="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-本地函数调用"><a href="#1-1-本地函数调用" class="headerlink" title="1.1 本地函数调用"></a>1.1 本地函数调用</h2><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    var a = <span class="hljs-number">2</span><br>    var b = <span class="hljs-number">3</span><br>    result := <span class="hljs-built_in">calculate</span>(a, b)<br>    fmt.<span class="hljs-built_in">Println</span>(result)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><br>func <span class="hljs-built_in">calculate</span>(x, y <span class="hljs-type">int</span>) &#123;<br>    z := x * y<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将 a 和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x 和 y</li><li>计算 x * y，并将结果存在 z</li><li>将 z 的值压栈，然后从 calculate 返回</li><li>从栈中取出 z 返回值，并赋值给 result</li></ol><h2 id="1-2-远程服务调用（RPC-Remote-Procedure-Calls）"><a href="#1-2-远程服务调用（RPC-Remote-Procedure-Calls）" class="headerlink" title="1.2 远程服务调用（RPC - Remote Procedure Calls）"></a>1.2 远程服务调用（RPC - Remote Procedure Calls）</h2><p>远程服务调用和本地服务调用相比，服务端和客户端之间肯定部署在不同的机器上&#x2F;中间隔着一个网络</p><p>RPC需要解决的问题：</p><ol><li>函数映射</li></ol><p>举例：网上商城</p><p><strong>问题一：网上商城如何告诉支付服务要实现付款&#x2F;充值？</strong></p><p>本地调用是使用函数指针调用，但是远程调用是两个进程，其地址空间都是不一样的。所以每个函数都有自己的ID，在RPC的时候需要附上函数ID。通过ID找到函数，然后再去执行</p><ol start="2"><li>数据转换成字节流</li></ol><p><strong>问题二：网上商城如何将参数告诉远程？</strong></p><p>本地调用直接参数压栈即可，远程调用中客户端和服务器是不同的进程，不能通过简单的内存传输，这个时候需要客户端先转换为一个字节流传输到服务端，再将字节流转换成自己能读取的格式</p><ol start="3"><li>网络传输</li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" class="" title="网络传输"></center><!-- <center><img src="网络传输.png"></center> --><p><strong>问题三：远程调用往往发生在网络上，如何保证网络上高效稳定地传输数据？</strong></p><h2 id="1-3-RPC-概念模型"><a href="#1-3-RPC-概念模型" class="headerlink" title="1.3 RPC 概念模型"></a>1.3 RPC 概念模型</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/RPC%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B.png" class="" title="RPC概念模型"></center><!-- <center><img src="RPC概念模型.png"></center> --><h2 id="1-4-一次-RPC-的完整过程"><a href="#1-4-一次-RPC-的完整过程" class="headerlink" title="1.4 一次 RPC 的完整过程"></a>1.4 一次 RPC 的完整过程</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%B8%80%E6%AC%A1RPC%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" class="" title="一次RPC的完整过程"></center><!-- <center><img src="一次RPC的完整过程.png"></center> --><p><strong>IDL（interface description language）文件</strong></p><p>IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不通过语音编写的程序可以相互通信</p><p><strong>生成代码</strong></p><p>通过编译器工具把 IDL 文件转换成语言对应的静态库</p><p><strong>编解码</strong></p><p>从内存中表示到字节序列的转换成为编码，反之为解码，也常叫做序列化和反序列化</p><p><strong>通信协议</strong></p><p>规范了数据再网络中的传输内容和格式。除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</p><p><strong>网络传输</strong></p><p>通常基于成熟的网络库走 TCP&#x2F;UDP 传输</p><h2 id="1-5-RPC-的好处"><a href="#1-5-RPC-的好处" class="headerlink" title="1.5 RPC 的好处"></a>1.5 RPC 的好处</h2><ol><li><p>单一职责，有利于分工协作和运维开发</p></li><li><p>可扩展性强，资源利用率更优</p></li><li><p>故障隔离，服务的整体可靠性更高</p></li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%8A%96%E9%9F%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="抖音架构图"></center><!-- <center><img src="抖音架构图.png"></center> --><h2 id="1-6-RPC-带来的问题"><a href="#1-6-RPC-带来的问题" class="headerlink" title="1.6 RPC 带来的问题"></a>1.6 RPC 带来的问题</h2><ol><li><p>服务宕机，对方如何处理？</p></li><li><p>在调用过程中发生网络异常，如何保证消息的可达性？</p></li><li><p>请求量突增导致无法及时处理，有哪些应对措施？</p></li></ol><p><strong>上述问题需要使用 RPC 框架处理</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>本地函数调用和 RPC 调用的区别：函数映射、数据转换成字节流、网络传输</p></li><li><p>RPC 概念模型：User、User-Stub、RPC-Runtime、Server-Stub、Server</p></li><li><p>一次 RPC 的完整过程，并讲解了 RPC 的基本概念定义</p></li><li><p>RPC 带来好处的同时也带来了不少新的问题，将由 RPC 框架来解决</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/03/hello-world/"/>
    <url>/2023/03/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
