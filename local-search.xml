<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Thrift、Protobuf和Avro的比较</title>
    <link href="/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2023/03/05/Thrift%E3%80%81Protobuf%E5%92%8CAvro%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p><strong>Thrift</strong> 是由 Facebook 主导开发的一个跨平台、支持多语言的，通过定义 IDL 文件，自动生成 RPC 客户端与服务端通信代码的工具，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码并由生成的代码负责RPC协议层和传输层的实现。</p><p><strong>Thrift</strong> 是由 Facebook 开源的一个RPC框架，用来进行可扩展且跨语言的服务的开发，使得各种编程语言间无缝结合的、高效的服务。我们依据Thrift的规范 简单定义访问接口，通过Thrift编译器编译生成各种编程语言代码，实现各种语言模块之间的高效互访问，速度比Google的Protocol Buffers还要快。Thrift可以说它是现在最优秀的分布式通信机制，实现了在大型分布式集群中各独立模块之间的高效协同</p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p><strong>protocol buffer</strong> 是一种序列化与结构化数据的一种机制，具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点。</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p><strong>Apache Avro</strong> 是一个二进制的数据序列化系统。实际上 Avro 除了序列化之外，像 MP 一样也提供了远程调用（ RPC ）功能。 Avro 是属于 Hadoop 的一个子项目，由 Hadoop 的 创始人 Doug Cutting 牵头开发，设计用于支持大批量数据交换的应用，依赖模式 (Schema) 来实现数据结构定义，模式由 JSON 对象来表示， Avro 也被作为一种 RPC 框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在 Avro 中被称为消息 (Message) 。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。</p><h2 id="二、框架优缺点分析"><a href="#二、框架优缺点分析" class="headerlink" title="二、框架优缺点分析"></a>二、框架优缺点分析</h2><h3 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h3><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li><li>proto文件生成目标代码，简单易用</li><li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li><li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li><li>支持多种语言（可以把proto文件看做IDL文件）</li><li>Netty等一些框架集成</li></ul><p><strong>缺点</strong></p><ul><li>官方只支持C++,JAVA和Python语言绑定</li><li>二进制可读性差（貌似提供了Text_Fromat功能）</li><li>二进制不具有自描述特性</li><li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li><li>只涉及序列化和反序列化技术，不涉及RPC功能（类似XML或者JSON的解析器）</li></ul><h3 id="Apache-Thrift"><a href="#Apache-Thrift" class="headerlink" title="Apache Thrift"></a>Apache Thrift</h3><p><strong>应用</strong></p><ul><li>Facebook的开源的日志收集系统(scribe: <a href="https://github.com/facebook/scribe">https://github.com/facebook/scribe</a>)</li><li>淘宝的实时数据传输平台(TimeTunnel <a href="http://code.taobao.org/p/TimeTunnel/wiki/index">http://code.taobao.org/p/TimeTunnel/wiki/index</a>)</li><li>Evernote开放接口(<a href="https://github.com/evernote/evernote-thrift">https://github.com/evernote/evernote-thrift</a>)</li><li>Quora(<a href="http://www.quora.com/Apache-Thrift">http://www.quora.com/Apache-Thrift</a>)</li><li>HBase( <a href="http://abloz.com/hbase/book.html#thrift">http://abloz.com/hbase/book.html#thrift</a> )</li><li>…</li></ul><p><strong>优点</strong></p><ul><li>支持非常多的语言绑定</li><li>thrift文件生成目标代码，简单易用</li><li>消息定义文件支持注释</li><li>数据结构与传输表现的分离，支持多种消息格式</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li></ul><p><strong>缺点</strong></p><ul><li>和protobuf一样不支持动态特性</li></ul><h3 id="Apache-Avro"><a href="#Apache-Avro" class="headerlink" title="Apache Avro"></a>Apache Avro</h3><p><strong>应用</strong></p><ul><li>Hadoop RPC （<a href="http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F%EF%BC%89">http://hadoop.apache.org/#What+Is+Apache+Hadoop%3F）</a></li></ul><p><strong>优点</strong></p><ul><li>二进制消息，性能好&#x2F;效率高</li><li>使用JSON描述模式</li><li>模式和数据统一存储，消息自描述，不需要生成stub代码（支持生成IDL）</li><li>RPC调用在握手阶段交换模式定义</li><li>包含完整的客户端&#x2F;服务端堆栈，可快速实现RPC</li><li>支持同步和异步通信</li><li>支持动态消息</li><li>模式定义允许定义数据的排序（序列化时会遵循这个顺序）</li><li>提供了基于Jetty内核的服务基于Netty的服务</li></ul><p><strong>缺点</strong></p><ul><li>只支持Avro自己的序列化格式</li><li>语言绑定不如Thrift丰富</li></ul><h2 id="三、性能对比"><a href="#三、性能对比" class="headerlink" title="三、性能对比"></a>三、性能对比</h2><p>由于thrift功能较protobuf丰富,因此单从序列化机制上进行性能比较,手机html制作按照序列化后字节数、序列化时间、反序列化时间三个指标进行对thrift的二进制、压缩、protobuf三种格式进行对比发现：Protobuf序列化后的字节数较少,符合w3c标准而且序列化和反序列化的时间也较短.</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p><strong>相同点：</strong></p><ol><li><strong>简化处理对xml文件的处理</strong></li></ol><ul><li>数据类型相对固定的情况下，不论是thrift还是protobuf都会比直接处理xml要方便很多</li></ul><blockquote><p>常用的跨语言通信方案：</p><ul><li>基于SOAP消息格式的WebService</li><li>基于JSON消息格式的RESTful 服务</li></ul><p>以上两种方案的弊端：</p><ul><li>XML体积太大，解析性能极差</li><li>JSON体积相对较小，解析相对较快，但表达能力较弱</li></ul></blockquote><p><strong>不同点：</strong></p><ol><li><strong>创作者</strong></li></ol><p>thrift由facebook出品，protobuffer由google出品；</p><ol start="2"><li><strong>语言支持</strong></li></ol><ul><li><p>Thrift: 支持的语言更广泛一些c++, java, python,ruby, csharp, haskell, ocmal, erlang, cocoa, php</p></li><li><p>protobuf 目前还是只支持c++, java, python</p></li></ul><ol start="3"><li><strong>协议支持</strong></li></ol><ul><li><p>Thrift支持多种协议格式. Thrift的代码实现，有专门的TProtocol和TTransport抽象，相互配合，可以实现多种协议，方便集成各种传输方式。至少目前Thrift就能使用json作为序列化协议。 </p></li><li><p>protobuf只安心一种协议，并下决心把这个格式做好。输入输出也是标准的stream。</p></li></ul><ol start="4"><li><strong>跨平台问题</strong></li></ol><ul><li><p>thrift目前不支持Windows平台 </p></li><li><p>protobuf没有这个问题，提供了visual studio的项目文件，可以很顺利的在windows平台下编译。</p></li></ul><ol start="5"><li><strong>易用性</strong></li></ol><ul><li>thrift侧重点是构建夸语言的可伸缩的服务，特点就是支持的语言多，同时提供了完整的rpc service framework，可以很方便的直接构建服务，不需要做太多其他的工作。</li></ul><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><p><a href="https://blog.csdn.net/hu2010shuai/article/details/53009349">https://blog.csdn.net/hu2010shuai/article/details/53009349</a></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC基本概念</title>
    <link href="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-本地函数调用"><a href="#1-1-本地函数调用" class="headerlink" title="1.1 本地函数调用"></a>1.1 本地函数调用</h2><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    var a = <span class="hljs-number">2</span><br>    var b = <span class="hljs-number">3</span><br>    result := <span class="hljs-built_in">calculate</span>(a, b)<br>    fmt.<span class="hljs-built_in">Println</span>(result)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><br>func <span class="hljs-built_in">calculate</span>(x, y <span class="hljs-type">int</span>) &#123;<br>    z := x * y<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将 a 和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x 和 y</li><li>计算 x * y，并将结果存在 z</li><li>将 z 的值压栈，然后从 calculate 返回</li><li>从栈中取出 z 返回值，并赋值给 result</li></ol><h2 id="1-2-远程服务调用（RPC-Remote-Procedure-Calls）"><a href="#1-2-远程服务调用（RPC-Remote-Procedure-Calls）" class="headerlink" title="1.2 远程服务调用（RPC - Remote Procedure Calls）"></a>1.2 远程服务调用（RPC - Remote Procedure Calls）</h2><p>远程服务调用和本地服务调用相比，服务端和客户端之间肯定部署在不同的机器上&#x2F;中间隔着一个网络</p><p>RPC需要解决的问题：</p><ol><li>函数映射</li></ol><p>举例：网上商城</p><p><strong>问题一：网上商城如何告诉支付服务要实现付款&#x2F;充值？</strong></p><p>本地调用是使用函数指针调用，但是远程调用是两个进程，其地址空间都是不一样的。所以每个函数都有自己的ID，在RPC的时候需要附上函数ID。通过ID找到函数，然后再去执行</p><ol start="2"><li>数据转换成字节流</li></ol><p><strong>问题二：网上商城如何将参数告诉远程？</strong></p><p>本地调用直接参数压栈即可，远程调用中客户端和服务器是不同的进程，不能通过简单的内存传输，这个时候需要客户端先转换为一个字节流传输到服务端，再将字节流转换成自己能读取的格式</p><ol start="3"><li>网络传输</li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" class="" title="网络传输"></center><!-- <center><img src="网络传输.png"></center> --><p><strong>问题三：远程调用往往发生在网络上，如何保证网络上高效稳定地传输数据？</strong></p><h2 id="1-3-RPC-概念模型"><a href="#1-3-RPC-概念模型" class="headerlink" title="1.3 RPC 概念模型"></a>1.3 RPC 概念模型</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/RPC%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B.png" class="" title="RPC概念模型"></center><!-- <center><img src="RPC概念模型.png"></center> --><h2 id="1-4-一次-RPC-的完整过程"><a href="#1-4-一次-RPC-的完整过程" class="headerlink" title="1.4 一次 RPC 的完整过程"></a>1.4 一次 RPC 的完整过程</h2><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%B8%80%E6%AC%A1RPC%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B.png" class="" title="一次RPC的完整过程"></center><!-- <center><img src="一次RPC的完整过程.png"></center> --><p><strong>IDL（interface description language）文件</strong></p><p>IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不通过语音编写的程序可以相互通信</p><p><strong>生成代码</strong></p><p>通过编译器工具把 IDL 文件转换成语言对应的静态库</p><p><strong>编解码</strong></p><p>从内存中表示到字节序列的转换成为编码，反之为解码，也常叫做序列化和反序列化</p><p><strong>通信协议</strong></p><p>规范了数据再网络中的传输内容和格式。除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</p><p><strong>网络传输</strong></p><p>通常基于成熟的网络库走 TCP&#x2F;UDP 传输</p><h2 id="1-5-RPC-的好处"><a href="#1-5-RPC-的好处" class="headerlink" title="1.5 RPC 的好处"></a>1.5 RPC 的好处</h2><ol><li><p>单一职责，有利于分工协作和运维开发</p></li><li><p>可扩展性强，资源利用率更优</p></li><li><p>故障隔离，服务的整体可靠性更高</p></li></ol><center><img src="/2023/03/05/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%8A%96%E9%9F%B3%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="抖音架构图"></center><!-- <center><img src="抖音架构图.png"></center> --><h2 id="1-6-RPC-带来的问题"><a href="#1-6-RPC-带来的问题" class="headerlink" title="1.6 RPC 带来的问题"></a>1.6 RPC 带来的问题</h2><ol><li><p>服务宕机，对方如何处理？</p></li><li><p>在调用过程中发生网络异常，如何保证消息的可达性？</p></li><li><p>请求量突增导致无法及时处理，有哪些应对措施？</p></li></ol><p><strong>上述问题需要使用 RPC 框架处理</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>本地函数调用和 RPC 调用的区别：函数映射、数据转换成字节流、网络传输</p></li><li><p>RPC 概念模型：User、User-Stub、RPC-Runtime、Server-Stub、Server</p></li><li><p>一次 RPC 的完整过程，并讲解了 RPC 的基本概念定义</p></li><li><p>RPC 带来好处的同时也带来了不少新的问题，将由 RPC 框架来解决</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/03/hello-world/"/>
    <url>/2023/03/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
